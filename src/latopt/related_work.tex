\section{Related Work}
\label{sec:related_work}

Our work conducts program transformations on the MIR intermediate
representation of Gao~\etal~\cite{soap2}. Alternative program representations
include \emph{static} and \emph{dynamic single assignment forms} (SSA,
DSA)~\cite{rau92, cytron91}, and \emph{control and data flow graphs}
(CDFG)~\cite{gajski94}. These representations are less suitable for our work
because they are all statement-based and do not identify as many equivalent
programs as MIRs do. Dependence graphs~\cite{rau94}, on the other hand, are
designed for the purpose of capturing data flow dependences in polyhedral
methods, but they generally do not preserve enough information for us to
reconstruct a program from the graph itself.

Several HLS tools exploit dependence graph restructuring to improve loop
parallelism, which allows for a smaller initiation interval, and in turn faster
programs.  Tree height reduction~\cite{nicolau91} aims to balance an arithmetic
expression tree using associativity and distributivity. Xilinx's Vivado HLS has
a similar feature called \emph{expression balancing}~\cite{vivado_hls}.  Both
of these methods do not produce optimal loop pipelining, as they do not examine
the implications of loop-carried dependences.  Canis \etal~\cite{canis14}
propose a similar approach called \emph{recurrence minimization}. They
specifically tackle loop pipelining by incrementally restructuring dependence
graphs to minimize longest paths of recurrences. Their method is subsequently
incorporated in LegUp~\cite{legup}, an open-source academic HLS tool.  However,
both LegUp and Vivado HLS only apply associativity in their restructuring.

Most importantly, none of the above mentioned techniques and tools aim to
minimize, or even analyze, the impact of their transformations on resource
usage and accuracy. In many numerically sensitive programs, small round-off
errors would result in catastrophic inaccurate results. Therefore, HLS tools
generally disable this feature by default for floating-point computations. For
this reason, we have developed our tool to optimize not only program latencies,
but also resource usage and accuracy.

Several authors have considered program transformations that improve
accuracy or resource usage. Both Damouche~\etal~\cite{damouche15} and
Panchekha \etal~\cite{panchekha15} propose methods for optimizing numerical
accuracy in software using equivalences from real arithmetic, but they
consider individual expressions only, and have no control structure
manipulation, such as optimizing across basic blocks or partial loop
unrolling.  Hosangadi \etal~\cite{hosangadi} minimize resource usage
by employing symbolic algebra to reduce the number of operations, and
Peymandoust~\etal~\cite{peymandoust} factorize polynomials using Gr{\"o}bner
bases; both only deal with polynomial arithmetic expressions. The \SOAP{} tool
of Gao~\etal~\cite{soap2} simultaneously optimizes numerical programs for
resource usage and accuracy, but is unable to analyze latency.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
